#!/usr/bin/env python

import os
import argparse
import glob
import json
from ConfigParser import SafeConfigParser

import numpy as np
from scipy.io import loadmat, savemat
import matplotlib.pyplot as plt
from mayavi import mlab

from chebpy import cheb_barycentric_matrix
from scftpy import SCFTConfig

parser = argparse.ArgumentParser(description='vis_slab3d options')

parser.add_argument('-b', '--batch',
                     action='store_true',
                     help='If present or True, perform batch mode.')
parser.add_argument('-r', '--path',
                     default='.',
                     help='Path to be processed, for batch mode use.')
parser.add_argument('-p', '--param_file',
                    default='param.ini',
                    help='SCFT configuration file, *.ini')
parser.add_argument('-d', '--data_file',
                     default='scft_out',
                    help='SCFT generated data file, *.mat')
parser.add_argument('-s', '--save',
                     action='store_true',
                     help='If present or True, save figure.')
args = parser.parse_args()


def batch_vis_slab3d(path='.', param='param.ini', data='scft_out'):
    '''
    Batch mode visdisk, for all directory in the <path>.
    Note: ONLY directories in the path will be processed.
    The input var <data> is the main part of the whole data file name. The
    suffix is in the form '_XXXX', where XXXX is the max number of time steps.
    Then the full data file name is 'scft_out_XXXX.mat', the '.mat' can be
    ignored.
    Generated figures are stored in the same directory as its data file. 
    Other data, such as H, are stored in the parent path as 'data.mat'.
    '''
    is_save = True # Do not show figure in the batch mode

    var = []
    F = []
    
    for f in os.listdir(path):
        p = os.path.join(path, f) # path
        if os.path.isdir(p):
            pfile = os.path.join(p, param)
            if not os.path.exists(pfile):
                print p, ' configuration file missing.'
                continue
            pt = os.path.join(p, data+'_*.mat') # path to be globbed
            datafiles = glob.glob(pt)
            fnames = [os.path.basename(x) for x in datafiles]
            data_name = get_final_data(fnames)
            if data_name == '':
                print p, ' data file missing.'
                continue
            dfile = os.path.join(p, data_name)
            vis_slab3d(pfile, dfile, is_save)
            print pfile, dfile

            #v = get_var(pfile)
            #var.append(v)
            #mat = loadmat(dfile)
            #F.append(mat['F'][-1,0])
            #print v, mat['F'][-1,0]

    savemat(os.path.join(path,'data'), {'v':var, 'F':F})


def get_var(param_file):
    '''
        Get the main batch variable and its current value.
    '''
    cfg = SafeConfigParser(allow_no_value=True)
    cfg.optionxform = str
    cfg.read(param_file)
    section = cfg.get('Batch', 'section')
    # name list of the batch variable
    batch_var = json.loads(cfg.get('Batch', 'var'))
    var_name = batch_var[0] # the main batch variable is the first one
    if (var_name == 'BC_coefficients_left' or 
        var_name == 'BC_coefficients_right'):
        bc = json.loads(cfg.get(section, var_name))
        var = bc[1]
    else:
        var = cfg.getfloat(section, var_name)
    return var


def get_final_data(namelist):
    '''
    Each name has the form 'scft_out_XXXX.mat', where XXXX is a number.
    '''
    data = ''
    num = 0 # a number to be compared
    for f in namelist:
        name, ext = os.path.splitext(f) # split into 'scft_out_XXXX', '.mat'
        fragments = name.split('_') # split into 'scft', 'out', 'XXXX'
        n = int(fragments[-1])
        if n > num:
            num = n
            data = name
    return data


def vis_slab3d(param='param.ini', data='scft_out', is_save=False):
    '''
        Visualize 3D data generated by SlabXX3D, here XX represents the polymer
        model, e.g. XX = AB stands for A-B diblock copolymers.
    '''
    is_show = not is_save
    path = os.path.dirname(data)

    config = SCFTConfig.from_file(param)
    Nx, Ny, Nz = config.grid.Lx, config.grid.Ly, config.grid.Lz
    Lx, Ly, Lz = config.uc.a, config.uc.b, config.uc.c
    print Nx, Ny, Nz
    print Lx, Ly, Lz

    mat = loadmat(data)
    phiA = mat['phiA']
    phiB = mat['phiB']
    phiAB = phiB - phiA

    if not (Nx, Ny, Nz) == phiA.shape:
        raise 'Data file does not match param file.'

    Nzp = 64 # display grid in z direction
    
    # Periodic in x and y directions, Fourier
    # Non-periodic in z direction, Chebyshev
    ii = np.arange(Nz)
    zz = np.cos(ii * np.pi / (Nz-1))
    zz = 0.5 * (1. + zz) * Lz
    zzp = np.linspace(0, Lz, Nzp)
    xp, yp, zp = np.mgrid[0:Lx*(1-1./Nx):Nx*1j, 
                          0:Ly*(1-1./Ny):Ny*1j, 
                          0:Lz:Nzp*1j]
    phiAp = cheb_interp3d_z(phiA, zzp)
    phiBp = cheb_interp3d_z(phiB, zzp)
    phiABp = phiBp - phiAp

    # To be visualized in Matlab by the m-script vislab3d.m
    data_disp = os.path.join(path, 'display.mat')
    savemat(data_disp, {'x':xp, 'y':yp, 'z':zp, 'phiA':phiAp, 'phiB':phiBp})

    if is_show:
        # Uncomment following lines to show the density profile along the z
        # direction. Note both original and interpolated data are shown.
        plt.plot(zz, phiA[Nx/2, Ny/2], '.')
        plt.plot(zz, phiB[Nx/2, Ny/2], '.')
        plt.plot(zz, phiAB[Nx/2, Ny/2], '.')
        plt.plot(zzp, phiAp[Nx/2, Ny/2])
        plt.plot(zzp, phiBp[Nx/2, Ny/2])
        plt.plot(zzp, phiABp[Nx/2, Ny/2])
        plt.show()
        mlab.clf()
        mlab.contour3d(xp, yp, zp, phiABp,
                       contours=32, transparent=True, 
                       colormap='Spectral')
        #src = mlab.pipeline.scalar_field(xp, yp, zp, phiABp)
        #mlab.pipeline.volume(src)
        mlab.show()
    if is_save:
        mlab.clf()
        mlab.contour3d(xp, yp, zp, phiABp,
                       contours=32, transparent=True, colormap='Spectral')
        figA = os.path.join(path, 'phiAB.png')
        mlab.savefig(figA)


def cheb_interp3d_z(u, vz):
    '''
    u(x,y,z): source data
    vz: vector to be interpolated, size is Nzp
    '''
    Nx, Ny, Nz = u.shape
    Nzp = vz.size
    uout = np.zeros([Nx, Ny, Nzp])
    vzp = np.linspace(-1, 1, Nzp)
    T = cheb_barycentric_matrix(vzp, Nz-1)
    #print Nx, Ny, Nz, Nzp, T.shape, u[0,0].shape
    for i in xrange(Nx):
        for j in xrange(Ny):
            uout[i,j] = np.dot(T, u[i,j])
    return uout


if __name__ == '__main__':
    if args.batch:
        batch_vis_slab3d(args.path, args.param_file, args.data_file)
    else:
        vis_slab3d(args.param_file, args.data_file, args.save)

