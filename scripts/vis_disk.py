#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
visdisk
=======

A script for displaying and saving density distribution generated by
scft_confined/DiskXX, where XX stands for the polymer model. For A-B diblock
copolymer, XX=AB.

Copyright (C) 2013 Yi-Xin Liu (lyx@fudan.edu.cn)

'''

import argparse
import os
import glob
import fnmatch

import numpy as np
from scipy.io import loadmat
import matplotlib.pylab as plt

from chebpy import cheb_barycentric_matrix

from scftpy import scft_contourf, SCFTConfig

parser = argparse.ArgumentParser(description='visdisk options')

parser.add_argument('-b', '--batch',
                     action='store_true',
                     help='If present or True, perform batch mode.')
parser.add_argument('-r', '--path',
                     default='.',
                     help='Path to be processed, for batch mode use.')
parser.add_argument('-p', '--param_file',
                    default='param.ini',
                    help='SCFT configuration file, *.ini')
parser.add_argument('-d', '--data_file',
                     default='scft_out',
                    help='SCFT generated data file, *.mat')
parser.add_argument('-s', '--save',
                     action='store_true',
                     help='If present or True, save figure.')
args = parser.parse_args()

def batch_vis_disk(path='.', param='param.ini', data='scft_out'):
    '''
    Batch mode visdisk, for all directory in the <path>.
    Note: ONLY directories in the path will be processed.
    The input var <data> is the main part of the whole data file name. The
    suffix is in the form '_XXXX', where XXXX is the max number of time steps.
    Then the full data file name is 'scft_out_XXXX.mat', the '.mat' can be
    ignored.
    Generated figures are stored in the same directory as its data file. 
    '''
    is_save = True # Do not show figure in the batch mode
    
    for f in os.listdir(path):
        p = os.path.join(path, f) # path
        if os.path.isdir(p):
            pt = os.path.join(p, data+'_*.mat') # path to be globbed
            datafiles = glob.glob(pt)
            fnames = [os.path.basename(x) for x in datafiles]
            data_name = get_final_data(fnames)
            pfile = os.path.join(p, param)
            dfile = os.path.join(p, data_name)
            vis_disk(pfile, dfile, is_save)
            print pfile, dfile


def get_final_data(namelist):
    '''
    Each name has the form 'scft_out_XXXX.mat', where XXXX is a number.
    '''
    data = ''
    num = 0 # a number to be compared
    for f in namelist:
        name, ext = os.path.splitext(f) # split into 'scft_out_XXXX', '.mat'
        fragments = name.split('_') # split into 'scft', 'out', 'XXXX'
        n = int(fragments[-1])
        if n > num:
            num = n
            data = name
    return data


def vis_disk(param='param.ini', data='scft_out', is_save=False):
    '''
    Visualize 2D data generated by DiskXX, here XX represents the polymer model,
    e.g. XX = AB stands for A-B diblock copolymers.
    '''
    is_show = not is_save
    path = os.path.dirname(data)

    config = SCFTConfig.from_file(param)
    Nt, Nr = config.grid.Lx, config.grid.Ly
    R = config.uc.a
    print Nt, Nr, R
    N2 = Nr / 2
    Ntp = Nt + 1
    Nrp = Nr

    mat = loadmat(data)
    phiA = mat['phiA']
    phiB = mat['phiB']
    #phiAB = phiA - phiB

    if not (Nt, N2) == phiA.shape:
        raise 'Data file does not match param file.'

    # Periodic in theta direction, Fourier
    ttp = np.linspace(0, 2*np.pi, Ntp)
    # Non-periodic in r direction, Chebyshev
    ii = np.arange(Nr)
    rr = np.cos(np.pi * ii / (Nr-1)) # rr [-1, 1]
    rr = rr[:N2] # rr in (0, 1] with rr[0] = 1
    rrp = np.linspace(0, R, Nrp)
    rp, tp = np.meshgrid(rrp, ttp)
    
    phiAp = np.zeros([Ntp, N2])
    phiBp = np.zeros([Ntp, N2])
    phiAp[:-1,:] = phiA
    phiAp[-1,:] = phiA[0,:]
    phiBp[:-1,:] = phiB
    phiBp[-1,:] = phiB[0,:]
    phiAp = cheb_interp2d_r(phiAp, rrp)
    phiBp = cheb_interp2d_r(phiBp, rrp)
    phiABp = phiAp - phiBp
    if is_show:
        scft_contourf(rp*np.cos(tp), rp*np.sin(tp), phiAp, show_cbar=True)
        scft_contourf(rp*np.cos(tp), rp*np.sin(tp), phiBp, show_cbar=True)
        scft_contourf(rp*np.cos(tp), rp*np.sin(tp), phiABp, show_cbar=True)
        plt.show()
    if is_save:
        figA = os.path.join(path, 'phiA.png')
        figB = os.path.join(path, 'phiB.png')
        figAB = os.path.join(path, 'phiAB.png')
        scft_contourf(rp*np.cos(tp), rp*np.sin(tp), phiAp)
        plt.savefig(figA)
        scft_contourf(rp*np.cos(tp), rp*np.sin(tp), phiBp)
        plt.savefig(figB)
        scft_contourf(rp*np.cos(tp), rp*np.sin(tp), phiABp)
        plt.savefig(figAB)


def cheb_interp2d_r(u, vr):
    '''
    Use chebyshev interpolation for the last dimension of polar coordinates
    (theta, r).
    u(theta, r): source data, note that the range of r is (0, 1]
    vr: vector to be interpolated, size is Nrp.
    '''
    Nt, N2 = u.shape
    Nrp = vr.size
    uout = np.zeros([Nt, Nrp])
    vrp = np.linspace(0, 1, Nrp)
    T = cheb_barycentric_matrix(vrp, 2*N2-1)
    for i in xrange(Nt):
        up = u[i]
        up = np.hstack((up, up[::-1]))
        uout[i] = np.dot(T, up)
    return uout


if __name__ == '__main__':
    if args.batch:
        batch_vis_disk(args.path, args.param_file, args.data_file)
    else:
        vis_disk(args.param_file, args.data_file, args.save)

